#+TITLE: Collections for XMMS2 v1.1
#+AUTHOR: SÃ©bastien Cevey
#+EMAIL: seb@cine7.net
#+OPTIONS: H:3
#+COLUMNS: %50ITEM %4Release(Ver.) %4Complexity %5Brainstorm{X}

#+PROPERTIES:
#+PROPERTY: Release_ALL v1.1 v1.2 v2.0
#+PROPERTY: Complexity_ALL triv easy med hard arg
#+PROPERTY: Brainstorm_ALL "[ ]"  "[X]"
#+END:

# Also link to related issues!

* New collection commands

** List all existing properties (keys) of all media in a collection
   :PROPERTIES:
   :Release:  v1.1
   :Complexity: easy
   :END:
   xmmsc_coll_property_list (coll, pattern = NULL)

   Use case: discover the existing properties for some media.

   possibly filtered by a pattern (same syntax as Match, i.e. _ and % wildcards).
?  pattern can be used to only find 'tag.*' properties, for instance.
?  also want to list sources

** List all values for a list of props in a collection
   :PROPERTIES:
   :Brainstorm: [X]
   :Release:  v1.1
   :Complexity: med
   :END:
   xmmsc_coll_property_values (coll, groupby = [])

   Use case: efficiently list specific properties (artist, album) for browsing.

?  should we have both a fetch and a groupby list (i.e. any sense to fetch fields we don't group by?)
?  what happens with Various Artists albums?
   allows to remove the groupby argument from query_infos
?  add start, limit offsets

** Get N random media from a collection
   :PROPERTIES:
   :Release:  v1.1
   :Complexity: easy
   :END:
   xmmsc_coll_random_get (coll, max = 1)

   Use case: needed for client-side party shuffle or anything like that.


* Querying

** Use functions as select fields (fetch), or matching field (e.g. compare dates, substring)
   :PROPERTIES:
   :Brainstorm: [X]
   :Release:  v1.2
   :Complexity: hard
   :END:

   Use case: special handling for dates (query, retrieve), use NOW(), etc.

** Aggregate functions:
   :PROPERTIES:
   :Brainstorm: [X]
   :Release:  v1.1
   :Complexity: med
   :END:

   - count  (function of "rows")
   - max, min, avg  (function of "values")
   - other?
   - make it generic?
   - combined with retrieving data, e.g. for each artist, count songs?
     is that even possible currently?

* Bindings

** Ruby: Collection operators as classes
   :PROPERTIES:
   :Release:  v1.1
   :Complexity: med
   :END:

   See C++ and python bindings.


* Concept

** Special "Virtuals" namespace, for
   :PROPERTIES:
   :Release:  v1.2
   :Complexity: med
   :END:

   Examples:
   - All Media
   - Current Track
   - Next Track
   - Active Playlist
   * Context(prev = 0, next = 0) ?

   Other namespaces: Tags, ...?

** Support medialists in DAG and queries, add ORDERBY and LIMIT collection operators
   :PROPERTIES:
   :Brainstorm: [X]
   :Release:  v2.0
   :Complexity: arg
   :END:

   keep the nature (set vs list) of the output of an operator in the DAG
   if filtering a medialist, let it remain a medialist
   implement Orderby and Limit to change the nature (un/ordered)
   requires intermediate results internally when querying..

** Handle sources properly [headaches ahead]
   :PROPERTIES:
   :Brainstorm: [X]
   :Release:  v2.0
   :Complexity: arg
   :END:

   use connection-saved sourcelist
   for values to match?
   for values to fetch?


* Internal Implementation

** Database

*** S4 (Short String Storage System)!
    :PROPERTIES:
    :Release:  v2.0
    :Complexity: arg
    :Brainstorm: [X]
    :END:
    (see [[http://wiki.xmms2.xmms.se/index.php/New_medialib_backend]["New medialib backend" wiki page]])

**** Basic operations:
     * Insert new media with a hash of properties
     * Update a media property
     * Remove a media
     * List the property keys/values of a media
     * Find all media by property value:
       - Exact match
       - Partial match
       - Match after operation (e.g. tolower())
       - Property existence
     * List property keys/values for an arbitrary set (e.g. list artists)
     * List existing properties for an arbitrary set

**** Additional features required:
     * Support sources
     * Support both sets and ordered lists
       - Allow conversion of sets to list (sort)
       - List operations (limit, filter, move, insert)
     * Advanced functions:
       - SUBSTR(s, i, l), YEAR(d), LIKE(s, p), CONTAINS(s, c)
       - 'd - NOW()', 'LEN(s) < 7'
     * Type-relevant operations (e.g. numeric comparison)
     * Native support for collection-like structures and queries?
     * Multiple property values?

**** XMMS2 specific features:

     * Determine whether an album is VA

*** Optimize query generation
    :PROPERTIES:
    :Release: 
    :Complexity: hard
    :END:

    at least avoid JOINs if not needed (no union), improve those too

*** Auto-sync (optional)  (see [[*Periodic DB-sync service client]])
    :PROPERTIES:
    :Complexity: 
    :END:

    every N updates or after timeout T after last update.
    add timer in medialib loop?

** CollParse

*** Virtual path patterns
    :PROPERTIES:
    :Release:  v1.2
    :Complexity: med
    :END:
    (see [[file:cli-browsing.org][CLI Browsing orgfile]])

*** Rewrite (?) more modular, allow plugging symbols/parsing in
    :PROPERTIES:
    :Release:  v1.2
    :Complexity: hard
    :END:

    Prototype first (python or ruby)
    Should be part of xmmscu.
    Completely customizable grammar.
    Allow to add state/query-dependent syntax, e.g.:
    * '_' current track
    * '+' previous pattern
    * '$album' current album

* External tools

** nycli!
   :PROPERTIES:
   :Complexity: med
   :END:

** Experiment PartyShuffle as a service client (standard, advanced)
   :PROPERTIES:
   :Complexity: med
   :END:

** DB-sync service client (see [[*Auto-sync]])
   :PROPERTIES:
   :Complexity: easy
   :END:

   after large updates (wait until they're done)
   and/or periodically
   configurable parameters


* Documentation

** Tutorials (clientlib + bindings)

** More developer doc

** Pattern syntax of collparser
