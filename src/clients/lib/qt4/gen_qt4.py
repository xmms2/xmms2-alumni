#!/usr/bin/env python
# encoding utf-8
# Thomas Frauendorfer, 2010

import sys

from waftools import genipc
from waftools.indenthelper import Indenthelper
from TaskGen import feature, before
import Task


EXT_GEN = ['.xml']

@feature('gen_qt4')
@before('cxx')
@before('apply_core')
def __init_gen_qt4(self):
	node = self.path.find_resource(self.ipcfile)
	ipc = genipc.parse_xml(node.abspath())

	fd = self.path.find_or_declare
	install_node = self.path.find_dir(self.include_dest.split('/'))
	hd = install_node.find_or_declare

	cxx_nodes = [fd([obj.name + '.cpp']) for obj in ipc.objects]
	hxx_nodes = [hd(['xmmsclientqt4', obj.name + '.h']) for obj in ipc.objects]

	gen_cxx = self.create_task('gen_qt4_cxx', node, cxx_nodes)
	gen_hcc = self.create_task('gen_qt4_hxx', node, hxx_nodes)

	for node in cxx_nodes:	
		self.allnodes.append(node)


type_map = {
    ('int',): 'qint32',
    ('string',): 'QString',
    ('collection',): 'Coll::Coll',
    ('binary',): 'QByteArray',
	('list', 'unknown'): 'QVariantList',
	('list', 'int'): 'QList<qint32> ',   
 	('list', 'string'): 'QStringList',
	('dictionary', 'unknown'): 'QVariantMap',
	('dictionary', 'int'): 'QMap<QString, qint32> ',
    ('dictionary', 'string'): 'QMap<QString, QString> ',
	('list', 'dictionary', 'unknown'): 'QList<QVariantMap> ',
	('dictionary', 'dictionary', 'unknown'): 'QMap<QString, QVariantMap> ',
}

def toQtType(argument):
	rettype = type_map.get(tuple(argument))
	#print "%s -> %s -> %s" % (str(argument), str(tuple(argument)), str(rettype))
	if not rettype:
		raise ValueError("gen_qt4: unsupported Type: %s" % str(argument))
	return rettype

def toConstQtType(argument):
	return "const %s &" % toQtType(argument)
	

def fix_methodname(name):
	if name == 'register':
		return 'registerClient'

	return name

def camel_case(s):
	return ''.join(x.capitalize() for x in s.split('_'))

#turns strings like "foo_bar" into "fooBar"
def camel_case2(s):
	sp = s.split('_')
	ret = sp[0]
	for x in sp[1:]:
		ret+=x.capitalize()
	return ret


def gen_qt4_hxx_files(self):
	ipc = genipc.parse_xml(self.inputs[0].abspath())

	objects = {}
	for obj in ipc.objects:
		objects[obj.name] = obj

	for node in self.outputs:
		o = objects[node.name[:-2]]
		if o == None:
			raise "Internal gen_qt4 error"
		gen_qt4_hxx_file(self, o, node)

def gen_qt4_hxx_file(ctx, obj, node):
	path = node.abspath(ctx.env)
	f = open(path, 'w');
	i = Indenthelper(f);

	i.printline('/* This file is automatically generated. Do not edit. */')
	i.printline()
	i.printline('#ifndef __XMMSCLIENT_QT_%s_H__' % obj.name)
	i.printline('#define __XMMSCLIENT_QT_%s_H__' % obj.name)
	i.printline()

	i.enter('namespace XMMSQt {')
	i.printline('class Client;')
	i.leave('}')

	i.printline('#include <xmmsclient/xmmsclientqt4/object.h>')
	i.printline('#include <xmmsclient/xmmsclientqt4/result.h>')
	i.printline()

	i.enter('namespace XMMSQt {')
	i.enter('class %s : public BaseObject {' % camel_case(obj.name))
	i.printline('Q_OBJECT')
	i.enter('public:')
	i.printline('%s (Client *client) : BaseObject (client)' % camel_case(obj.name))
	i.printline('{')
	i.printline('};')
	i.leave()
	i.printline()

	if obj.methods:
		i.enter('public slots:')
		for method in obj.methods:
			emit_method_header(i, obj, method, '')
			i.printline()
		i.leave()

	if obj.signals:
		i.enter('public:')
		for signal in obj.signals:
			emit_method_header(i, obj, signal, 'signal_')
			i.printline()
		i.leave()

	if obj.broadcasts:
		i.enter('public:')
		for broadcast in obj.broadcasts:
			emit_method_header(i, obj, broadcast, 'broadcast_')
			i.printline()
		i.leave()


	i.leave('};')
	i.leave('}')

	i.printline('#endif')

	f.close()

def emit_method_header(i, obj, method, name_prefix):
	method_name = name_prefix + method.name
	method_name = fix_methodname(method_name)

	arguments = getattr(method, 'arguments', [])
	return_value = getattr(method, 'return_value')

	# first, write documentation for this method
	i.printline('/** %s' % method.documentation)
	i.printline(' *')

	if len(arguments) > 0:
		for a in arguments:
			i.printline(' * @param %s %s' % (a.name, a.documentation))
		i.printline(' *')

	if return_value:
		i.printline(' * @return %s' % return_value.documentation)
	else:
		i.printline(' * @return a Result class')
	i.printline(' *')
	i.printline(' */')
    # now write the method definition
	s = '();';
	if len(arguments) > 0:
		s = '(%s);' % ', '.join(["%s %s" % (toConstQtType(a.type), a.name) for a in arguments])

	if return_value:
		i.printline('ResultT< %s > %s %s' % (toQtType(return_value.type), camel_case2(method_name), s))
	else:
		i.printline('ResultT< void > %s %s' % (camel_case2(method_name), s))

def gen_qt4_cxx_files(self):
	ipc = genipc.parse_xml(self.inputs[0].abspath())

	objects = {}
	for obj in ipc.objects:
		objects[obj.name] = obj

	for node in self.outputs:
		o = objects[node.name[:-4]]
		if o == None:
			raise "Internal gen_qt4 error"
		gen_qt4_cxx_file(self, o, node)

def gen_qt4_cxx_file(ctx, obj, node):
	path = node.abspath(ctx.env)
	f = open(path, 'w')
	i = Indenthelper(f)

	i.printline('#include <QVariant>')
	i.printline('#include <QString>')
	i.printline('#include <QStringList>')
	i.printline('#include <xmmsclient/xmmsclientqt4/%s.h>' % obj.name)
	i.printline('#include <xmmsclient/xmmsclientqt4/client.h>')
	i.printline('#include <xmmsclient/xmmsclientqt4/coll.h>')
	i.printline()

	i.enter('namespace XMMSQt {')
	i.printline()

	for method in obj.methods:
		emit_method_body(i, obj, method)
		i.printline()

	for method in obj.signals:
		emit_signal_body(i, obj, method)
		i.printline()

	for method in obj.broadcasts:
		emit_broadcast_body(i, obj, method)
		i.printline()

	i.printline()
	i.leave('}') # namespace

	i.printline()
	i.printline('#include "xmmsclient/xmmsclientqt4/%s.moc"' % obj.name)

	f.close()

def emit_method_body(i, obj, method):
	method_name = camel_case2(method.name)
	method_name = fix_methodname(method_name)
	arguments = getattr(method, 'arguments', [])
	args = '()'
	if len(arguments) > 0:
		args = '(%s)' % ', '.join(["%s %s" % (toConstQtType(a.type), a.name) for a in arguments])

	return_value = getattr(method, 'return_value')
	return_type = 'void'
	if return_value:
		return_type = toQtType(return_value.type)

	i.printline('ResultT< %s >' % return_type)
	i.printline('%s::%s %s' % (camel_case(obj.name), method_name, args))
	i.enter('{')

	i.printline('QVariantList params;')
	for a in arguments:
		i.printline('params.append (QVariant::fromValue(%s));' % a.name)
	i.printline('Message msg (%d, %d, params);' % (obj.id, method.id))
	i.printline ('return m_client->queueMsg (msg);')

	i.leave('}')
	
def emit_signal_body(i, obj, method):
	method_name = camel_case2('signal_' + method.name)
	method_name = fix_methodname(method_name)
	arguments = getattr(method, 'arguments', [])
	args = '()'
	if len(arguments) > 0:
		args = '(%s)' % ', '.join(["%s %s" % (toConstQtType(a.type), a.name) for a in arguments])

	return_value = getattr(method, 'return_value')
	return_type = 'void'
	if return_value:
		return_type = toQtType(return_value.type)

	i.printline('ResultT< %s >' % return_type)
	i.printline('%s::%s %s' % (camel_case(obj.name), method_name, args))
	i.enter('{')

	i.printline('QVariantList params;')
	i.printline('params.append (%d);' % method.id)
	for a in arguments:
		i.printline('params.append (QVariant::fromValue(%s));' % a.name)
	i.printline('Message msg (0, 32, params);')
	i.printline ('return m_client->queueMsg (msg);')

	i.leave('}')
	
def emit_broadcast_body(i, obj, method):
	method_name = camel_case2('broadcast_' + method.name)
	method_name = fix_methodname(method_name)
	arguments = getattr(method, 'arguments', [])
	args = '()'
	if len(arguments) > 0:
		args = '(%s)' % ', '.join(["%s %s" % (type_map.get(tuple(a.type)), a.name) for a in arguments])

	return_value = getattr(method, 'return_value')
	return_type = 'void'
	if return_value:
		return_type = toQtType(return_value.type)

	i.printline('ResultT< %s >' % return_type)
	i.printline('%s::%s %s' % (camel_case(obj.name), method_name, args))
	i.enter('{')

	i.printline('QVariantList params;')
	i.printline('params.append (%d);' % method.id)
	for a in arguments:
		i.printline('params.append (QVariant::fromValue(%s));' % a.name)
	i.printline('Message msg (0, 33, params);')
	i.printline ('return m_client->queueMsg (msg);')

	i.leave('}')
	

Task.task_type_from_func('gen_qt4_hxx', func=gen_qt4_hxx_files, before='cxx moc qxx_task')
Task.task_type_from_func('gen_qt4_cxx', func=gen_qt4_cxx_files, before='cxx moc qxx_task')
